<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<!--
`optinomic-chart-profile`
Profile Charts

@demo demo/index.html 
-->
<dom-module id="optinomic-chart-profile">
    <template>
        <style include="iron-flex iron-flex-alignment">
        :host {
            display: block;
            --grafic-width: 480px;
            --grafic-height: 50px;
            --grafic-margin: 0px;
            --grafic-top-space: 0px;
            --grafic-text-visibility: hidden;
            --item-height: 50px;
        }
        
        div.relative {
            position: relative;
            width: 100%;
            height: var(--grafic-height);
        }
        
        div.absolute_left {
            position: absolute;
            top: var(--grafic-top-space);
            left: 0;
            width: var(--grafic-margin);
            height: var(--grafic-height);
            visibility: var(--grafic-text-visibility);
            text-align: right;
        }
        
        div.absolute_right {
            position: absolute;
            top: var(--grafic-top-space);
            right: 0;
            width: var(--grafic-margin);
            height: var(--grafic-height);
            visibility: var(--grafic-text-visibility);
            text-align: left;
        }
        
        div.absolute_center {
            position: absolute;
            top: 0;
            left: var(--grafic-margin);
            width: var(--grafic-size);
            height: var(--grafic-height);
        }
        
        div.description_item {
            padding-right: 6px;
            padding-left: 6px;
            height: var(--item-height);
            overflow: hidden;
        }
        
        .grid-border-top {
            border-top-color: #E0E0E0;
            border-top-style: solid;
            border-top-width: 1px;
        }
        </style>
        <div id="svg_grafic" class="relative">
            <!-- START - Grafik -->
            <p>[[d.grafic_width]] </p>
            <div class="absolute_center">
                <template is="dom-if" if="[[scales_set]]">
                    <svg-container id="svg_container" view-box$="0 0 100 [[d.grafic_height]]" width="[[d.grafic_wight]]px" height$="[[d.grafic_height]]px">
                        <svg-component is="g" id="baseGrid">
                            <template is="dom-repeat" items="[[scales]]" as="scale">
                                <svg-component is="line" x1="0" y1$="[[scale.bottomline]]" x2$="[[d.grafic_width]]" y2$="[[scale.bottomline]]" stroke$="[[d.color_grid]]" stroke-width="0.5">
                                </svg-component>
                                <template is="dom-if" if="[[scale.first]]">
                                    <svg-component is="line" x1="0" y1$="[[scale.topline]]" x2$="[[d.grafic_width]]" y2$="[[scale.topline]]" stroke$="[[d.color_grid]]" stroke-width="0.5">
                                    </svg-component>
                                </template>
                                <template is="dom-if" if="[[d.show_baseline]]">
                                    <svg-component is="line" x1="0" y1$="[[scale.baseline]]" x2$="[[d.grafic_width]]" y2$="[[scale.baseline]]" stroke$="[[d.color_grid]]" stroke-width="1">
                                    </svg-component>
                                </template>
                            </template>
                        </svg-component>
                    </svg-container>
                </template>
                <template is="dom-if" if="[[!scales_set]]">
                    <p>NOT</p>
                </template>
            </div>
            <!-- Skalenbeschriftung Links/Rechts -->
            <template is="dom-if" if="[[d.wide]]">
                <div class="absolute_left">
                    <template is="dom-repeat" id="right_beschriftung" items="[[scales]]" as="s">
                        <div class="description_item fade horizontal layout">
                            <div class="flex self-center">
                                <div class="layout horizontal flex">
                                    <p class="description_item_title flex right">[[s.left_title]]</p>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                <div class="absolute_right">
                    <template is="dom-repeat" id="left_beschriftung" items="[[scales]]" as="s">
                        <div class="description_item fade horizontal layout">
                            <div class="flex self-center">
                                <div class="layout horizontal flex self-center">
                                    <p class="description_item_title flex">[[s.right_title]]</p>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
        </div>
        <!-- DEBUG -->
        <div>
        </div>
    </template>
    <script>
    Polymer({

        is: 'optinomic-chart-profile',

        __init: function() {
            // Scales @ Properties
            this.scales = this.scales === undefined ? [] : this.scales;

            // Ranges @ Properties
            this.ranges = this.ranges === undefined ? [] : this.ranges;

            // Scores @ Properties
            this.scores = this.scores === undefined ? {} : this.scores;

            // Options @ Properties
            var d = this.options === undefined ? {} : this.options;
            d.item_height = d.item_height === undefined ? 50 : d.item_height;
            d.item_text_width = d.item_text_width === undefined ? 120 : d.item_text_width;
            d.response_title_path = d.response_title_path === undefined ? null : d.response_title_path;
            d.response_subtitle_path = d.response_subtitle_path === undefined ? null : d.response_subtitle_path;
            d.min = d.min === undefined ? "auto" : d.min;
            d.max = d.max === undefined ? "auto" : d.max;
            d.range_alpha = d.range_alpha === undefined ? 0.1 : d.range_alpha;


            // Resize
            d.wide = false;
            d.wide_breakpoint = 480;

            // Grafic Size
            d.grafic_top_space = 20;
            d.grafic_width = 480;
            d.grafic_margin = d.item_text_width;
            d.grafic_text_visibility = 'hidden';
            d.grafic_height = d.item_height * (this.scales.length) + this.scales.length + d.grafic_top_space;


            console.log('(✓) Options', d);

            // Set Data
            this.set('d', d);

            // Follow the white Rabbit
            this.__setScales();
        },

        __setScales: function() {
            var d = this.get('d');
            var scales = this.get('scales');
            var scores = this.get('scores.data');

            __getScorePath = function(current_score, path) {
                var dots_count = (path.split(".").length - 1)

                var dive = [];
                for (i = 0; i < dots_count; i++) {
                    var n = path.indexOf(".");
                    var item = path.substring(0, n);
                    path = path.substring(n + 1, path.length);
                    dive.push(item);
                    if (i === dots_count - 1) {
                        dive.push(path);
                    };
                };

                var return_value = null;
                var data_dive = JSON.parse(JSON.stringify(current_score));

                // console.log('__getScorePath', data_dive, path);

                for (i = 0; i < dive.length; i++) {
                    data_dive = data_dive[dive[i]];
                    if (i === dots_count) {
                        return_value = data_dive;

                        return return_value;
                    };
                };
            };

            scales.forEach(function(scale, scaleID) {
                scale.id = scaleID;
                scale.topline = scaleID * d.item_height + d.grafic_top_space;
                scale.baseline = scale.topline + (d.item_height / 2);
                scale.bottomline = scale.topline + d.item_height;

                scale.first = false;
                if (scaleID === 0) {
                    scale.first = true;
                };

                scale.last = false;
                if (scaleID === scales.length - 1) {
                    scale.last = true;
                };

                scale.scores = [];
                scores.forEach(function(score, scoreID) {
                    var score_obj = {
                        "value": null
                    };

                    // Get Values
                    if (scale.score_path) {
                        score_obj.value = this.__getScorePath(score, scale.score_path);
                    };

                    if (d.response_title_path) {
                        score_obj.title = this.__getScorePath(score, d.response_title_path);
                    };

                    if (d.response_subtitle_path) {
                        score_obj.subtitle = this.__getScorePath(score, d.response_subtitle_path);
                    };

                    scale.scores.push(score_obj);
                });
            });

            // Set Data
            this.set('scales_set', true);
            console.log('(✓) Scales', this.scales);

            // Auto Min/Max
            var do_min = false;
            if ((d.min === 'auto') || (d.min === undefined)) {
                do_min = true;
            } else {
                item_min = parseInt(d.min);
            };

            var do_max = false;
            if ((d.max === 'auto') || (d.max === undefined)) {
                do_max = true;
            } else {
                item_max = parseInt(d.max);
            };

            if (do_max || do_min) {
                this.set('d', __autoMinMax(do_min, do_max, d, this.scales));
            };


            // Follow the white Rabbit
            this.__setRanges();
        },

        __setRanges: function() {
            var ranges = this.get('ranges');
            var d = this.get('d');

            if (ranges.length > 0) {
                ranges.forEach(function(range, rangeID) {
                    range.id = rangeID;
                    range.rgb = hexToRGB(range.color, d.range_alpha);

                    range.start = range.range_start;
                    if (range.range_start === -999) {
                        range.start = d.item_min;
                    };

                    range.stop = range.range_stop;
                    if (range.range_stop === 999) {
                        range.stop = d.item_max;
                    };

                    range.start_pos = __getXPos(d.item_min, d.item_max, d.grafic_width, range.start);
                    range.stop_pos = __getXPos(d.item_min, d.item_max, d.grafic_width, range.stop);

                    range.width = range.stop_pos - range.start_pos;
                    range.x = __getXPos(d.item_min, d.item_max, d.grafic_width, range.start);

                    range.height = d.grafic_height;
                });
                console.log('__setRanges', this.ranges);
            };
            this.set('ranges', ranges);
        },

        __resizeGrafic: function(wide) {
            wide = wide === undefined ? false : wide;

            var full_width = this.$.svg_grafic.offsetWidth;

            this.set('d.grafic_width', 480);


            if (wide) {
                this.set('d.grafic_width', full_width - (2 * this.d.grafic_margin));
                this.set('d.grafic_text_visibility', 'visible');

                this.customStyle['--grafic-margin'] = this.d.grafic_margin + 'px';
            } else {
                this.set('d.grafic_width', full_width);
                this.set('d.grafic_text_visibility', 'hidden');

                this.customStyle['--grafic-margin'] = '0px';
            };

            // Apply
            this.customStyle['--grafic-top-space'] = this.d.grafic_top_space + 'px';
            this.customStyle['--item-height'] = this.d.item_height + 'px';
            this.customStyle['--grafic-height'] = this.d.grafic_height + 'px';
            this.customStyle['--grafic-size'] = this.d.grafic_width + 'px';
            this.customStyle['--grafic-text-visibility'] = this.d.grafic_text_visibility;

            this.updateStyles();

            //console.log('__getGraficWidth', this.d);
        },

        __onIronResize: function() {
            var width = Math.floor(this._parent.offsetWidth);
            //var height = Math.floor(this.parent.offsetHeight);

            if (width <= this.d.wide_breakpoint) {
                this.set('d.wide', false);
            } else {
                this.set('d.wide', true);
            };
            this.__resizeGrafic(this.d.wide);
        },

        behaviors: [
            Polymer.IronResizableBehavior
        ],

        listeners: {
            'iron-resize': '__onIronResize'
        },



        properties: {
            options: {
                type: Object
            },
            start: {
                type: Object
            },
            scales: {
                type: Object
            },
            scores: {
                type: Object
            },
            ranges: {
                type: Object
            },
            _d: {
                type: Object
            }
        },

        attached: function() {
            //this.__getGraficWidth();
        },

        ready: function() {
            this.__init();
        },


        get _parent() {
            if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                return this.parentNode.host;
            }
            return this.parentNode;
        },

    });

    getColor = function(id) {
        var colors = [];
        colors.push("#3F51B5");
        colors.push("#E91E63");
        colors.push("#00BCD4");
        colors.push("#8BC34A");
        colors.push("#FFC107");
        colors.push("#795548");

        colors.push("#673AB7");
        colors.push("#F44336");
        colors.push("#03A9F4");
        colors.push("#4CAF50");
        colors.push("#FFEB3B");
        colors.push("#FF5722");

        colors.push("#2196F3");
        colors.push("#9C27B0");
        colors.push("#009688");
        colors.push("#CDDC39");
        colors.push("#FF9800");
        colors.push("#607D8B");

        var selected_id = id;

        return colors[selected_id];
    };

    hexToRGB = function(hex, alpha) {
        var h = "0123456789ABCDEF";
        var r = h.indexOf(hex[1]) * 16 + h.indexOf(hex[2]);
        var g = h.indexOf(hex[3]) * 16 + h.indexOf(hex[4]);
        var b = h.indexOf(hex[5]) * 16 + h.indexOf(hex[6]);
        if (alpha) return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
        else return "rgb(" + r + ", " + g + ", " + b + ")";
    };

    __autoMinMax = function(do_min, do_max, d, all_scales) {
        // Init
        if (do_min) {
            d.item_min = 0;
        };
        if (do_max) {
            d.item_max = 0;
        };

        // Check in scales/scores
        all_scales.forEach(function(scale, scaleID) {
            scale.scores.forEach(function(score, scoreID) {
                if (do_min) {
                    if (score.value < d.item_min) {
                        d.item_min = score.value;
                    };
                };
                if (do_max) {
                    if (score.value > d.item_max) {
                        d.item_max = score.value;
                    };
                };
            });
        });


        //Round a number upward to its nearest integer:

        if (do_min) {
            if (d.item_min < 0) {
                d.item_min = Math.ceil(Math.abs(d.item_min)) + 1;
                d.item_min = d.item_min * -1;
            } else {
                d.item_min = Math.ceil(Math.abs(d.item_min)) + 1;
            };
        };
        if (do_max) {
            if (d.item_max < 0) {
                d.item_max = Math.ceil(Math.abs(d.item_max)) + 1;
                d.item_max = d.item_max * -1;
            } else {
                d.item_max = Math.ceil(Math.abs(d.item_max)) + 1;
            };
        };

        return d;
    };

    __getXPos = function(min, max, svg_width_100, current_value) {
        var width_value = null
        if (current_value !== undefined) {
            current_value = current_value;

            var width_100 = Math.abs(min) + Math.abs(max);
            width_value = (svg_width_100 / width_100) * (current_value + Math.abs(min));
        };
        return width_value;
    };

    formatDateCH = function(date_string) {
        if (date_string !== undefined) {

            // 1952-11-19T00:00:00.000000000000Z
            var year = parseInt(date_string.substring(0, 4));
            var month = parseInt(date_string.substring(5, 7));
            var day = parseInt(date_string.substring(8, 10));
            var date_string_return = day + "." + month + "." + year

            return date_string_return;
        } else {
            return null;
        }
    };
    </script>
</dom-module>
<!-- 
http://plnkr.co/edit/pegYFTcr9koAZEg7pTMf?p=preview
-->
<dom-module id="svg-container">
    <template>
        <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" preserveAspectRatio="xMinYMin meet"></svg>
        <content select="svg-component"></content>
    </template>
    <script>
    Polymer({
        is: 'svg-container',

        attached: function() {
            for (var i = 0; i < this.attributes.length; i++) {
                this.$.svg.setAttribute(Polymer.CaseMap.dashToCamelCase(this.attributes[i].name), this.attributes[i].value);
            }
        }
    });
    </script>
</dom-module>
<dom-module id="svg-component">
    <template>
        <content select="svg-component"></content>
    </template>
    <script>
    SvgComponent = Polymer({
        is: 'svg-component',

        _node: {},

        _namespace: 'http://www.w3.org/2000/svg',

        get rootElement() {
            if (this.parentNode.nodeName === 'SVG-CONTAINER')
                return this.parentNode.$.svg;
            else
                return this.parentNode._node;
        },

        factoryImpl: function(attributes) {
            for (var key in attributes)
                this.setAttribute(key, attributes[key]);
        },

        attached: function() {
            var is = this.attributes.is.value;

            if (is !== undefined) {
                this._node = document.createElementNS(this._namespace, is);

                for (var i = 0; i < this.attributes.length; i++) {
                    if (this.attributes[i].name !== 'is')
                        this._node.setAttribute(this.attributes[i].name, this.attributes[i].value);
                }
                this.rootElement.appendChild(this._node);
            }
        }
    });
    </script>
</dom-module>
